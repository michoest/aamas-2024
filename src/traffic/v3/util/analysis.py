# Contains methods for analyzing and visualizing the data generated by sequential and
# single-step simulations.

from collections import Counter
import math

import pandas as pd
import networkx as nx
import matplotlib as mpl
import matplotlib.pyplot as plt


def plot_social_welfare(step_stats, *, ax=plt):
    (-step_stats["travel_time"]).mean(axis=1).plot(ax=ax, title="Social welfare")
    ax.legend(["Social Welfare"])


def plot_travel_time_per_route(car_stats, *, ax=plt):
    car_stats.groupby(["step", "route"])["travel_time"].mean().unstack().plot(ax=ax, title="Travel time per route")
    ax.legend()


def plot_cars_per_edge(car_stats, *, ax=plt):
    pd.DataFrame(
        list(
            car_stats.groupby("step")["route"].aggregate(
                lambda routes: Counter(
                    [edge for route in routes for edge in tuple(zip(route, route[1:]))]
                )
            )
        )
    ).fillna(0).plot(ax=ax, title="Number of cars per edge")
    ax.legend()


def plot_latency_per_edge(step_stats, *, ax=plt):
    step_stats['latency'].plot(ax=ax)


def plot_cars_per_route(car_stats, *, ax=plt):
    car_stats.groupby(["step", "route"]).size().unstack().fillna(0).plot(
        ax=ax, title="Number of cars per route"
    )
    ax.legend()


def plot_toll_per_edge(step_stats, *, ax=plt):
    step_stats['toll'].plot(ax=ax, title='Toll per edge')
    ax.legend()


def draw_edge_utilization(model, car_stats, show_std=False, ax=plt):
    edge_utilization = (
        (
            pd.DataFrame(
                list(
                    car_stats.groupby("step")["route"].aggregate(
                        lambda routes: Counter(
                            [
                                edge
                                for route in routes
                                for edge in tuple(zip(route, route[1:]))
                            ]
                        )
                    )
                )
            )
            / len(model.cars)
        )
        .mean()
        .to_dict()
    )

    edge_utilization_std = (
        (
            pd.DataFrame(
                list(
                    car_stats.groupby("step")["route"].aggregate(
                        lambda routes: Counter(
                            [
                                edge
                                for route in routes
                                for edge in tuple(zip(route, route[1:]))
                            ]
                        )
                    )
                )
            )
            / len(model.cars)
        )
        .std()
        .to_dict()
    )

    if show_std:
        edge_labels = {
            edge: f"{edge_utilization[edge]:.2f} (+- {edge_utilization_std[edge]:.1f})"
            for edge in edge_utilization
        }
    else:
        edge_labels = {
            edge: f"{edge_utilization[edge]:.2f}" for edge in edge_utilization
        }

    ax.title("Mean utilization of edges")
    nx.draw(
        model.network,
        ax=ax,
        pos=nx.get_node_attributes(model.network, "position"),
        edgelist=edge_utilization.keys(),
        edge_color=edge_utilization.values(),
        edge_vmax=1.0,
        edge_vmin=0.0,
        with_labels=True,
        font_size=10,
        edge_cmap=mpl.colormaps["Greys"],
    )
    nx.draw_networkx_edge_labels(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels=edge_labels,
        font_size=8,
    )


def get_latency_label(a, b, c):
    label = 'l(n) = ' + ('0' if a == 0 and b == 0 else '')
    label += (f'{a:.0f}' if math.floor(a) == a else f'{a:.2f}') if a != 0 else ''

    if b == 0:
        return label

    label += (' + ' if b > 0 else ' - ') if a != 0 else ''
    label += (f'{b:.0f}' if math.floor(a) == a else f'{b:.2f}') if b != 1 else ''
    label += 'n'
    label += (f'^{c:.0f}' if math.floor(a) == a else f'^{c:.2f}') if c != 1 else ''

    return label


def draw_latency_params(model, ax=plt):
    ax.title("Parameters for latency function l(n) = a + b * n ** c")
    nx.draw(
        model.network,
        ax=ax,
        pos=nx.get_node_attributes(model.network, "position"),
        connectionstyle="arc3,rad=0.2",
    )
    nx.draw_networkx_edge_labels(
        model.network,
        ax=ax,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels={
            (
                v,
                w,
            ): get_latency_label(*model.network.edges[(v, w)]["latency_params"])
            for v, w in model.network.edges
        },
    )


def plot_latency_increase_per_edge(model, step_stats, ax=plt):
    free_flow_latencies = {
        (v, w): attr["latency_fn"](0) for v, w, attr in model.network.edges(data=True)
    }
    mean_latencies = step_stats["latency"].mean().to_dict()

    # Note that free flow latencies are always > 0 in the BPR paradigm
    latency_increase = {
        edge: (mean_latencies[edge] / free_flow_latencies[edge]) - 1.0
        for edge in model.network.edges
        if mean_latencies[edge] > free_flow_latencies[edge]
    }

    edge_labels = {edge: f"{increase:.1%}" for edge, increase in latency_increase.items()}

    ax.title("Latency increase per edge")
    nx.draw(
        model.network,
        ax=ax,
        pos=nx.get_node_attributes(model.network, "position"),
        edgelist=latency_increase.keys(),
        edge_color=latency_increase.values(),
        edge_vmax=1.0,
        edge_vmin=0.0,
        with_labels=True,
        font_size=10,
        edge_cmap=mpl.colormaps["Greys"],
    )
    nx.draw_networkx_edge_labels(
        model.network,
        ax=ax,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels=edge_labels,
        font_size=8,
    )


def plot_summary(model, step_stats, car_stats):
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

    plot_social_welfare(step_stats, ax=ax1)
    plot_cars_per_route(car_stats, ax=ax2)
    draw_edge_utilization(model, car_stats, ax=ax3)
