# Contains methods for analyzing and visualizing the data generated by sequential and
# single-step simulations.

from collections import Counter

import pandas as pd
import networkx as nx
import matplotlib as mpl


def plot_travel_time_per_route(car_stats):
    car_stats.groupby("route")["travel_time"].plot(legend=True)


def plot_cars_per_edge(car_stats):
    pd.DataFrame(
        list(
            car_stats.groupby("step")["route"].aggregate(
                lambda routes: Counter(
                    [edge for route in routes for edge in tuple(zip(route, route[1:]))]
                )
            )
        )
    ).plot()


def plot_cars_per_route(car_stats):
    car_stats.groupby(["step", "route"]).size().unstack().plot()


def draw_edge_utilization(model, car_stats, show_std=False):
    edge_utilization = (
        (
            pd.DataFrame(
                list(
                    car_stats.groupby("step")["route"].aggregate(
                        lambda routes: Counter(
                            [
                                edge
                                for route in routes
                                for edge in tuple(zip(route, route[1:]))
                            ]
                        )
                    )
                )
            )
            / len(model.cars)
        )
        .mean()
        .to_dict()
    )
    edge_utilization_std = (
        (
            pd.DataFrame(
                list(
                    car_stats.groupby("step")["route"].aggregate(
                        lambda routes: Counter(
                            [
                                edge
                                for route in routes
                                for edge in tuple(zip(route, route[1:]))
                            ]
                        )
                    )
                )
            )
            / len(model.cars)
        )
        .std()
        .to_dict()
    )

    if show_std:
        edge_labels = {
            edge: f"{edge_utilization[edge]:.2f} (+- {edge_utilization_std[edge]:.1f})"
            for edge in edge_utilization
        }
    else:
        edge_labels = {
            edge: f"{edge_utilization[edge]:.2f}" for edge in edge_utilization
        }

    nx.draw(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edgelist=edge_utilization.keys(),
        edge_color=edge_utilization.values(),
        edge_vmax=1.0,
        edge_cmap=mpl.colormaps["Greys"],
    )
    nx.draw_networkx_edge_labels(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels=edge_labels,
    )


def draw_latency_params(model):
    nx.draw(model.network, pos=nx.get_node_attributes(model.network, "position"))
    nx.draw_networkx_edge_labels(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels={
            (
                v,
                w,
            ): f'{model.network.edges[(v, w)]["latency_params"]}\n{model.network.edges[(w, v)]["latency_params"]}'
            for v, w in model.network.edges
            if v < w
        },
    )


def plot_latency_increase_per_edge(car_stats):
    # edge_latency = (pd.DataFrame(list(stats2.groupby('step')['route'].aggregate(lambda routes: Counter([edge for route in routes for edge in tuple(zip(route, route[1:]))])))) / len(model.cars)).mean().to_dict()
    # edge_utilization_std = (pd.DataFrame(list(stats2.groupby('step')['route'].aggregate(lambda routes: Counter([edge for route in routes for edge in tuple(zip(route, route[1:]))])))) / len(model.cars)).std().to_dict()

    # if show_std:
    #     edge_labels = {edge: f'{edge_utilization[edge]:.2f} (+- {edge_utilization_std[edge]:.1f})' for edge in edge_utilization}
    # else:
    #     edge_labels = {edge: f'{edge_utilization[edge]:.2f}' for edge in edge_utilization}

    # nx.draw(model.network, pos=nx.get_node_attributes(model.network, 'position'), edgelist=edge_utilization.keys(), edge_color=edge_utilization.values(), edge_vmax=1.0, edge_cmap=mpl.colormaps['Greys'])
    # nx.draw_networkx_edge_labels(model.network, pos=nx.get_node_attributes(model.network, 'position'), edge_labels=edge_labels)
