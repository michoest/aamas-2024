# Contains methods for analyzing and visualizing the data generated by sequential and
# single-step simulations.

from collections import Counter

import pandas as pd
import networkx as nx
import matplotlib as mpl
import matplotlib.pyplot as plt


def plot_social_welfare(step_stats):
    (-step_stats["travel_time"]).mean(axis=1).plot(title="Social welfare")
    plt.legend(["Social Welfare"])


def plot_travel_time_per_route(car_stats):
    car_stats.groupby(["step", "route"])["travel_time"].mean().unstack().plot(title="Travel time per route")
    plt.legend()


def plot_cars_per_edge(car_stats):
    pd.DataFrame(
        list(
            car_stats.groupby("step")["route"].aggregate(
                lambda routes: Counter(
                    [edge for route in routes for edge in tuple(zip(route, route[1:]))]
                )
            )
        )
    ).fillna(0).plot(title="Number of cars per edge")
    plt.legend()


def plot_cars_per_route(car_stats):
    car_stats.groupby(["step", "route"]).size().unstack().fillna(0).plot(
        title="Number of cars per route"
    )
    plt.legend()


def plot_toll_per_edge(step_stats):
    step_stats['toll'].plot(title='Toll per edge')
    plt.legend()


def draw_edge_utilization(model, car_stats, show_std=False):
    edge_utilization = (
        (
            pd.DataFrame(
                list(
                    car_stats.groupby("step")["route"].aggregate(
                        lambda routes: Counter(
                            [
                                edge
                                for route in routes
                                for edge in tuple(zip(route, route[1:]))
                            ]
                        )
                    )
                )
            )
            / len(model.cars)
        )
        .mean()
        .to_dict()
    )

    edge_utilization_std = (
        (
            pd.DataFrame(
                list(
                    car_stats.groupby("step")["route"].aggregate(
                        lambda routes: Counter(
                            [
                                edge
                                for route in routes
                                for edge in tuple(zip(route, route[1:]))
                            ]
                        )
                    )
                )
            )
            / len(model.cars)
        )
        .std()
        .to_dict()
    )

    if show_std:
        edge_labels = {
            edge: f"{edge_utilization[edge]:.2f} (+- {edge_utilization_std[edge]:.1f})"
            for edge in edge_utilization
        }
    else:
        edge_labels = {
            edge: f"{edge_utilization[edge]:.2f}" for edge in edge_utilization
        }

    plt.title("Mean utilization of edges")
    nx.draw(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edgelist=edge_utilization.keys(),
        edge_color=edge_utilization.values(),
        edge_vmax=1.0,
        edge_vmin=0.0,
        with_labels=True,
        font_size=10,
        edge_cmap=mpl.colormaps["Greys"],
    )
    nx.draw_networkx_edge_labels(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels=edge_labels,
        font_size=8,
    )


def draw_latency_params(model):
    plt.title("Parameters for latency function l(n) = a + b * n ** c")
    nx.draw(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        connectionstyle="arc3,rad=0.2",
    )
    nx.draw_networkx_edge_labels(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels={
            (
                v,
                w,
            ): f'{model.network.edges[(v, w)]["latency_params"]}\n{model.network.edges[(w, v)]["latency_params"]}'
            for v, w in model.network.edges
            if v < w
        },
    )


def plot_latency_increase_per_edge(model, step_stats):
    free_flow_latencies = {
        (v, w): attr["latency_fn"](0) for v, w, attr in model.network.edges(data=True)
    }
    mean_latencies = step_stats["latency"].mean().to_dict()

    latency_increase = {
        edge: (mean_latencies[edge] / (free_flow_latencies[edge] + 0.0001)) - 1.0
        for edge in model.network.edges
        if mean_latencies[edge] > free_flow_latencies[edge]
    }

    edge_labels = {edge: f"{increase:.1%}" for edge, increase in latency_increase.items()}

    plt.title("Latency increase per edge")
    nx.draw(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edgelist=latency_increase.keys(),
        edge_color=latency_increase.values(),
        edge_vmax=1.0,
        edge_vmin=0.0,
        with_labels=True,
        font_size=10,
        edge_cmap=mpl.colormaps["Greys"],
    )
    nx.draw_networkx_edge_labels(
        model.network,
        pos=nx.get_node_attributes(model.network, "position"),
        edge_labels=edge_labels,
        font_size=8,
    )
